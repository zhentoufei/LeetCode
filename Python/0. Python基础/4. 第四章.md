### 1. 如何使用多线程
**实际案例**  
我们通过雅虎网站获取了中国股市某只股票[csv数据文件](http://table.finance.yahoo.com/table.csv?s=000001.sz)，现在要下载多只股票的csv数据，并将其转换为xml文件
如何使用多线程来跳高下载处理的效率？
**解决方案**  
使用标准库threading.Thread创建线程，在每一个线程中下载并转换已知股票数据
```python
# coding:utf-8
# 简单的线程使用
import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO


# 美化xml的输出
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


def download(url):
    response = requests.get(url, timeout=3)
    if response.ok:
        return StringIO(response.content)


def csv2xml(scsv, fxml):
    reader = csv.reader(scsv)
    headers = reader.next()
    headers = map(lambda h: h.repace(' ', ''), headers)
    root = Element('Data')
    for row in reader:
        eRow = Element('Row')
        root.append(eRow)
        for tag, text in zip(headers, row):
            e = Element(tag)
            e.text = text
            eRow.append(e)

    pretty(root)
    et = ElementTree(root)
    et.write(fxml)


def handle(sid):
    url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
    url %= str(sid).rjust(6, '0')
    rf = download(url)
    if rf is None:
        return

    print 'Convert to xml ...(%d)' % sid
    fname = str(sid).rjust(6, '0') + '.xml'
    with open(fname, 'wb') as wf:
        csv2xml(rf, wf)

class MyThread(Thread):
    def run(self):
        

from threading import Thread
if __name__ == '__main__':
    t = Thread(target=handle, args=(1,))
    t.start()
    print 'main thread...'
```
```python
# coding:utf-8
# 将线程写成一个类，封装起来
import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO

from threading import Thread


# 美化xml的输出
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


def download(url):
    response = requests.get(url, timeout=3)
    if response.ok:
        return StringIO(response.content)


def csv2xml(scsv, fxml):
    reader = csv.reader(scsv)
    headers = reader.next()
    headers = map(lambda h: h.repace(' ', ''), headers)
    root = Element('Data')
    for row in reader:
        eRow = Element('Row')
        root.append(eRow)
        for tag, text in zip(headers, row):
            e = Element(tag)
            e.text = text
            eRow.append(e)

    pretty(root)
    et = ElementTree(root)
    et.write(fxml)


def handle(sid):
    url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
    url %= str(sid).rjust(6, '0')
    rf = download(url)
    if rf is None:
        return

    print 'Convert to xml ...(%d)' % sid
    fname = str(sid).rjust(6, '0') + '.xml'
    with open(fname, 'wb') as wf:
        csv2xml(rf, wf)


class MyThread(Thread):
    def __init__(self, sid):
        Thread.__init__(self)
        self.sid = sid

    def run(self):
        handle(self.sid)
        pass


if __name__ == '__main__':
    t = MyThread(1)
    t.start()
    t.join() # 保证子线程运行完毕再退出主线程
    
    
    
    # 多个线程的等待退出
    threads = []
    for i in xrange(1, 11):
        t = MyThread(i)
        threads.append(t)
        t.start()

    for t in threads:
        t.join()  # 让等待每个子线程的退出
```
**注意**：python中的线程不适合处理cpu密集型的操作，因为有个全局解释器锁，导致每个时刻只有一个线程被一个python解释器执行，只适合处理IO型的操作
### 2. 如何进行线程间的通信
**实际案例**  
如1中的案例
由于全局解释器锁的存在，多线程进行CPU密集型操作并不能提高执行效率，我们修改程序架构：
1. 使用多个DownloadThread线程进行下载(I/O操作)
2. 使用一个ConvertThread线程进行转换(CPU密集型操作)
3. 下载线程把下载数据安全地传递给转换线程
**解决方案**  
使用标准库中的Queue.Queue，它是一个线程安全的队列，Download线程把下载数据放入队列，Convert线程从队列里提取数据	
```python
# coding:utf-8

import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO

from threading import Thread
from Queue import Queue


# 美化xml的输出
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


class DownloadThread(Thread):
    def __init__(self, sid, queue):
        Thread.__init__(self)
        self.sid = sid
        self.url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
        self.url %= str(sid).rjust(6, '0')
        self.queue = queue

    def download(self, url):
        response = requests.get(url, timeout=3)
        if response.ok:
            return StringIO(response.content)

    def run(self):
        # 1.下载
        data = self.download(self.url)
        # 2. sid, data
        # lock
        self.queue.put((self.sid, data))


class ConverThread(Thread):
    def __init__(self, queue):
        Thread.__init__(self)
        self.queue = queue

    def csv2xml(self, scsv, fxml):
        reader = csv.reader(scsv)
        headers = reader.next()
        headers = map(lambda h: h.repace(' ', ''), headers)
        root = Element('Data')
        for row in reader:
            eRow = Element('Row')
            root.append(eRow)
            for tag, text in zip(headers, row):
                e = Element(tag)
                e.text = text
                eRow.append(e)

        pretty(root)
        et = ElementTree(root)
        et.write(fxml)

    def run(self):
        while True:
            # sid, data
            sid, data = self.queue.get()
            if sid == -1:
                break
            if data:
                fname = str(self.sid).rjust(6, '0') + '.xml'
                with open(fname, 'wb') as wf:
                    self.csv2xml(self.data, wf)


if __name__ == '__main__':
    q = Queue()
    dThreads = [DownloadThread(i, q) for i in xrange(1, 11)]
    cThread = ConverThread(q)
    for t in dThreads:
        t.start()
    cThread.start()
    for t in dThreads:
        t.join()
    q.put(-1, None)
```
### 3. 进行线程间的时间通知？
**实际案例**  
如1中的案例
*额外需求*  
实现一个线程，将转换出的xml文件压缩打包，比如转换线程没生产出100个xml文件，就通知打包线程将他们打包成一个xxx.tgz文件，并删除xml文件，打包完成过后，打包线程反过来通知转换线程，转换线程继续转换
**解决方案**  
线程间的事件通知，可以使用标准库中的Thread.Event:
1. 等待事件一端调用wait，等待事件
2. 通知事件一端调用set，通知事件