### 1. å¦‚ä½•ä½¿ç”¨å¤šçº¿ç¨‹
**å®žé™…æ¡ˆä¾‹**  
æˆ‘ä»¬é€šè¿‡é›…è™Žç½‘ç«™èŽ·å–äº†ä¸­å›½è‚¡å¸‚æŸåªè‚¡ç¥¨[csvæ•°æ®æ–‡ä»¶](http://table.finance.yahoo.com/table.csv?s=000001.sz)ï¼ŒçŽ°åœ¨è¦ä¸‹è½½å¤šåªè‚¡ç¥¨çš„csvæ•°æ®ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºxmlæ–‡ä»¶
å¦‚ä½•ä½¿ç”¨å¤šçº¿ç¨‹æ¥è·³é«˜ä¸‹è½½å¤„ç†çš„æ•ˆçŽ‡ï¼Ÿ  

**è§£å†³æ–¹æ¡ˆ**  
ä½¿ç”¨æ ‡å‡†åº“threading.Threadåˆ›å»ºçº¿ç¨‹ï¼Œåœ¨æ¯ä¸€ä¸ªçº¿ç¨‹ä¸­ä¸‹è½½å¹¶è½¬æ¢å·²çŸ¥è‚¡ç¥¨æ•°æ®
```python
# coding:utf-8
# ç®€å•çš„çº¿ç¨‹ä½¿ç”¨
import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO


# ç¾ŽåŒ–xmlçš„è¾“å‡º
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


def download(url):
    response = requests.get(url, timeout=3)
    if response.ok:
        return StringIO(response.content)


def csv2xml(scsv, fxml):
    reader = csv.reader(scsv)
    headers = reader.next()
    headers = map(lambda h: h.repace(' ', ''), headers)
    root = Element('Data')
    for row in reader:
        eRow = Element('Row')
        root.append(eRow)
        for tag, text in zip(headers, row):
            e = Element(tag)
            e.text = text
            eRow.append(e)

    pretty(root)
    et = ElementTree(root)
    et.write(fxml)


def handle(sid):
    url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
    url %= str(sid).rjust(6, '0')
    rf = download(url)
    if rf is None:
        return

    print 'Convert to xml ...(%d)' % sid
    fname = str(sid).rjust(6, '0') + '.xml'
    with open(fname, 'wb') as wf:
        csv2xml(rf, wf)

class MyThread(Thread):
    def run(self):
        

from threading import Thread
if __name__ == '__main__':
    t = Thread(target=handle, args=(1,))
    t.start()
    print 'main thread...'
```
```python
# coding:utf-8
# å°†çº¿ç¨‹å†™æˆä¸€ä¸ªç±»ï¼Œå°è£…èµ·æ¥
import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO

from threading import Thread


# ç¾ŽåŒ–xmlçš„è¾“å‡º
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


def download(url):
    response = requests.get(url, timeout=3)
    if response.ok:
        return StringIO(response.content)


def csv2xml(scsv, fxml):
    reader = csv.reader(scsv)
    headers = reader.next()
    headers = map(lambda h: h.repace(' ', ''), headers)
    root = Element('Data')
    for row in reader:
        eRow = Element('Row')
        root.append(eRow)
        for tag, text in zip(headers, row):
            e = Element(tag)
            e.text = text
            eRow.append(e)

    pretty(root)
    et = ElementTree(root)
    et.write(fxml)


def handle(sid):
    url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
    url %= str(sid).rjust(6, '0')
    rf = download(url)
    if rf is None:
        return

    print 'Convert to xml ...(%d)' % sid
    fname = str(sid).rjust(6, '0') + '.xml'
    with open(fname, 'wb') as wf:
        csv2xml(rf, wf)


class MyThread(Thread):
    def __init__(self, sid):
        Thread.__init__(self)
        self.sid = sid

    def run(self):
        handle(self.sid)
        pass


if __name__ == '__main__':
    t = MyThread(1)
    t.start()
    t.join() # ä¿è¯å­çº¿ç¨‹è¿è¡Œå®Œæ¯•å†é€€å‡ºä¸»çº¿ç¨‹
    
    
    
    # å¤šä¸ªçº¿ç¨‹çš„ç­‰å¾…é€€å‡º
    threads = []
    for i in xrange(1, 11):
        t = MyThread(i)
        threads.append(t)
        t.start()

    for t in threads:
        t.join()  # è®©ç­‰å¾…æ¯ä¸ªå­çº¿ç¨‹çš„é€€å‡º
```
**æ³¨æ„**ï¼špythonä¸­çš„çº¿ç¨‹ä¸é€‚åˆå¤„ç†cpuå¯†é›†åž‹çš„æ“ä½œï¼Œå› ä¸ºæœ‰ä¸ªå…¨å±€è§£é‡Šå™¨é”ï¼Œå¯¼è‡´æ¯ä¸ªæ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹è¢«ä¸€ä¸ªpythonè§£é‡Šå™¨æ‰§è¡Œï¼Œåªé€‚åˆå¤„ç†IOåž‹çš„æ“ä½œ
### 2. å¦‚ä½•è¿›è¡Œçº¿ç¨‹é—´çš„é€šä¿¡
**å®žé™…æ¡ˆä¾‹**  
å¦‚1ä¸­çš„æ¡ˆä¾‹
ç”±äºŽå…¨å±€è§£é‡Šå™¨é”çš„å­˜åœ¨ï¼Œå¤šçº¿ç¨‹è¿›è¡ŒCPUå¯†é›†åž‹æ“ä½œå¹¶ä¸èƒ½æé«˜æ‰§è¡Œæ•ˆçŽ‡ï¼Œæˆ‘ä»¬ä¿®æ”¹ç¨‹åºæž¶æž„ï¼š
1. ä½¿ç”¨å¤šä¸ªDownloadThreadçº¿ç¨‹è¿›è¡Œä¸‹è½½(I/Oæ“ä½œ)
2. ä½¿ç”¨ä¸€ä¸ªConvertThreadçº¿ç¨‹è¿›è¡Œè½¬æ¢(CPUå¯†é›†åž‹æ“ä½œ)
3. ä¸‹è½½çº¿ç¨‹æŠŠä¸‹è½½æ•°æ®å®‰å…¨åœ°ä¼ é€’ç»™è½¬æ¢çº¿ç¨‹   

**è§£å†³æ–¹æ¡ˆ**  
ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„Queue.Queueï¼Œå®ƒæ˜¯ä¸€ä¸ªçº¿ç¨‹å®‰å…¨çš„é˜Ÿåˆ—ï¼ŒDownloadçº¿ç¨‹æŠŠä¸‹è½½æ•°æ®æ”¾å…¥é˜Ÿåˆ—ï¼ŒConvertçº¿ç¨‹ä»Žé˜Ÿåˆ—é‡Œæå–æ•°æ®	
```python
# coding:utf-8

import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO

from threading import Thread
from Queue import Queue


# ç¾ŽåŒ–xmlçš„è¾“å‡º
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


class DownloadThread(Thread):
    def __init__(self, sid, queue):
        Thread.__init__(self)
        self.sid = sid
        self.url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
        self.url %= str(sid).rjust(6, '0')
        self.queue = queue

    def download(self, url):
        response = requests.get(url, timeout=3)
        if response.ok:
            return StringIO(response.content)

    def run(self):
        # 1.ä¸‹è½½
        data = self.download(self.url)
        # 2. sid, data
        # lock
        self.queue.put((self.sid, data))


class ConverThread(Thread):
    def __init__(self, queue):
        Thread.__init__(self)
        self.queue = queue

    def csv2xml(self, scsv, fxml):
        reader = csv.reader(scsv)
        headers = reader.next()
        headers = map(lambda h: h.repace(' ', ''), headers)
        root = Element('Data')
        for row in reader:
            eRow = Element('Row')
            root.append(eRow)
            for tag, text in zip(headers, row):
                e = Element(tag)
                e.text = text
                eRow.append(e)

        pretty(root)
        et = ElementTree(root)
        et.write(fxml)

    def run(self):
        while True:
            # sid, data
            sid, data = self.queue.get()
            if sid == -1:
                break
            if data:
                fname = str(self.sid).rjust(6, '0') + '.xml'
                with open(fname, 'wb') as wf:
                    self.csv2xml(self.data, wf)


if __name__ == '__main__':
    q = Queue()
    dThreads = [DownloadThread(i, q) for i in xrange(1, 11)]
    cThread = ConverThread(q)
    for t in dThreads:
        t.start()
    cThread.start()
    for t in dThreads:
        t.join()
    q.put(-1, None)
```
### 3. è¿›è¡Œçº¿ç¨‹é—´çš„æ—¶é—´é€šçŸ¥ï¼Ÿ
**å®žé™…æ¡ˆä¾‹**  
å¦‚1ä¸­çš„æ¡ˆä¾‹
*é¢å¤–éœ€æ±‚*  
å®žçŽ°ä¸€ä¸ªçº¿ç¨‹ï¼Œå°†è½¬æ¢å‡ºçš„xmlæ–‡ä»¶åŽ‹ç¼©æ‰“åŒ…ï¼Œæ¯”å¦‚è½¬æ¢çº¿ç¨‹æ²¡ç”Ÿäº§å‡º100ä¸ªxmlæ–‡ä»¶ï¼Œå°±é€šçŸ¥æ‰“åŒ…çº¿ç¨‹å°†ä»–ä»¬æ‰“åŒ…æˆä¸€ä¸ªxxx.tgzæ–‡ä»¶ï¼Œå¹¶åˆ é™¤xmlæ–‡ä»¶ï¼Œæ‰“åŒ…å®Œæˆè¿‡åŽï¼Œæ‰“åŒ…çº¿ç¨‹åè¿‡æ¥é€šçŸ¥è½¬æ¢çº¿ç¨‹ï¼Œè½¬æ¢çº¿ç¨‹ç»§ç»­è½¬æ¢  
**è§£å†³æ–¹æ¡ˆ**  
çº¿ç¨‹é—´çš„äº‹ä»¶é€šçŸ¥ï¼Œå¯ä»¥ä½¿ç”¨æ ‡å‡†åº“ä¸­çš„Thread.Event:
1. ç­‰å¾…äº‹ä»¶ä¸€ç«¯è°ƒç”¨waitï¼Œç­‰å¾…äº‹ä»¶
2. é€šçŸ¥äº‹ä»¶ä¸€ç«¯è°ƒç”¨setï¼Œé€šçŸ¥äº‹ä»¶  
```python
# coding:utf-8

import csv
from xml.etree.ElementTree import Element, ElementTree
import requests
from StringIO import StringIO

from threading import Thread, Event
from Queue import Queue
import tarfile
import os


# ç¾ŽåŒ–xmlçš„è¾“å‡º
def pretty(e, level=0):
    if len(e) > 0:
        e.text = '\n' + '\t' * (level + 1)
        for child in e:
            pretty(child, level + 1)
        child.tail = child.tail[:-1]
    e.tail = '\n' + '\t' * level


class DownloadThread(Thread):
    def __init__(self, sid, queue):
        Thread.__init__(self)
        self.sid = sid
        self.url = 'http://table.finance.yahoo.com/table.csv?s=000001.sz'
        self.url %= str(sid).rjust(6, '0')
        self.queue = queue

    def download(self, url):
        response = requests.get(url, timeout=3)
        if response.ok:
            return StringIO(response.content)

    def run(self):
        # 1.ä¸‹è½½
        data = self.download(self.url)
        # 2. sid, data
        # lock
        self.queue.put((self.sid, data))


class ConverThread(Thread):
    def __init__(self, queue, cEvent, tEvent):
        Thread.__init__(self)
        self.queue = queue
        self.cEvent = cEvent
        self.tEvent = tEvent

    def csv2xml(self, scsv, fxml):
        reader = csv.reader(scsv)
        headers = reader.next()
        headers = map(lambda h: h.repace(' ', ''), headers)
        root = Element('Data')
        for row in reader:
            eRow = Element('Row')
            root.append(eRow)
            for tag, text in zip(headers, row):
                e = Element(tag)
                e.text = text
                eRow.append(e)

        pretty(root)
        et = ElementTree(root)
        et.write(fxml)

    def run(self):
        count = 0
        while True:
            # sid, data
            sid, data = self.queue.get()
            if sid == -1:
                self.cEvent.set()
                self.tEvent.wait()
                break
            if data:
                fname = str(self.sid).rjust(6, '0') + '.xml'
                with open(fname, 'wb') as wf:
                    self.csv2xml(self.data, wf)
                count += 1
                if count == 5:
                    self.cEvent.set()
                    self.tEvent.wait()
                    self.tEvent.clear()
                    count = 0


# è®¾ç½®æˆå®ˆæŠ¤çº¿ç¨‹ï¼Œåœ¨å…¶ä»–çº¿ç¨‹æ²¡æœ‰çš„æ—¶å€™ï¼Œè¿™ä¸ªçº¿ç¨‹ä¹Ÿå°±æ²¡äº†
class TarThread(Thread):
    def __init__(self, cEvent, tEvent):
        Thread.__init__(self)
        self.count = 0
        self.cEvent = cEvent
        self.tEvent = tEvent
        self.setDaemon(True)  # è®¾ç½®å®ˆæŠ¤çº¿ç¨‹

    def tarXml(self):
        self.count += 1
        tfname = '%d.tgz' % self.count
        tf = tarfile.open(tfname, 'w:gz')
        for fname in os.listdir('.'):
            tf.add(fname)
            os.remove(fname)
        tf.close()

        if not tf.members:
            os.remove(tfname)

    def run(self):
        while True:
            self.cEvent.wait()
            self.tarXml()
            self.cEvent.clear()

            self.tEvent.set()


if __name__ == '__main__':
    q = Queue()
    dThreads = [DownloadThread(i, q) for i in xrange(1, 11)]

    cEvent = Event()
    tEvent = Event()

    cThread = ConverThread(q, cEvent, tEvent)
    tThread = TarThread(cEvent, tEvent)
    tThread.start()
    for t in dThreads:
        t.start()
    cThread.start()
    for t in dThreads:
        t.join()
    q.put(-1, None)
```
### 2. çº¿ç¨‹æ± ï¼Ÿ
**å®žé™…æ¡ˆä¾‹**  
æˆ‘ä»¬å®žçŽ°äº†ä¸€ä¸ªå¤šçº¿ç¨‹webè§†é¢‘ç›‘æŽ§æœåŠ¡å™¨ï¼Œæˆ‘ä»¬è¦å¯¹è¯·æ±‚è¿žæŽ¥æ•°åšé™åˆ¶ï¼Œä»¥é˜²æ­¢æ¶æ„ç”¨æˆ·å‘èµ·å¤§é‡è¿žæŽ¥è€Œå¯¼è‡´æœåŠ¡å™¨åˆ›å»ºå¤§é‡æƒ³æˆï¼Œæœ€ç»ˆå› èµ„æºè€—å°½è€Œç˜«ç—ª
å¯ä»¥ä½¿ç”¨çº¿ç¨‹æ± æ›¿ä»£åŽŸæ¥çš„æ¯æ¬¡è¯·æ±‚åˆ›å»ºçº¿ç¨‹  
**è§£å†³æ–¹æ¡ˆ**  
ä½¿ç”¨æ ‡å‡†åº“ä¸­concurrent.futuresä¸‹çš„ThreadPoolExecutorå¯¹è±¡çš„submitå’Œmapæ–¹æ³•å¯ä»¥æ¥å¯åŠ¨çº¿ç¨‹æ± ä¸­çº¿ç¨‹æ‰§è¡Œä»»åŠ¡

```python
# coding:utf-8
# å…ˆæ¥ä¸€ä¸ªå°ðŸŒ°
from concurrent.futures import ThreadPoolExecutor
import time

executor = ThreadPoolExecutor(2)  # æœ€å¤šä¸¤ä¸ªçº¿ç¨‹


def f(a, b):
    print('f', a, b)
    time.sleep(2)
    return a ** b


print executor.submit(f, 2, 3)

future = executor.submit(f, 2, 4)
print future.result()  # èŽ·å¾—ç»“æžœ

# è®¡ç®—å¤šä¸ªå‡½æ•° 2**5, 3**6, 4**7
print executor.map(f, [2, 3, 4], [5, 6, 7])

```
```python
# coding:utf-8

import os, cv2,  struct, threading
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import TCPServer, ThreadingTCPServer
from threading import Thread, RLock
from select import select
from concurrent.futures import ThreadPoolExecutor


class JpegStreamer(Thread):
    def __init__(self, camera):
        Thread.__init__(self)
        self.cap = cv2.VideoCapture(camera)
        self.lock = RLock()
        self.pipes = {}

    def register(self):
        pr, pw = os.pipe()
        self.lock.acquire()
        self.pipes[pr] = pw
        self.lock.release()
        return pr

    def unregister(self, pr):
        self.lock.acquire()
        pw = self.pipes.pop(pr)
        self.lock.release()
        os.close(pr)
        os.close(pw)

    def capture(self):
        cap = self.cap
        while cap.isOpened():
            ret, frame = cap.read()
            if ret:
                # ret, data = cv2.imencode('.jpg', frame)
                ret, data = cv2.imencode('.jpg', frame, (cv2.IMWRITE_JPEG_QUALITY, 40))
                yield data.tostring()

    def send(self, frame):
        n = struct.pack('l', len(frame))
        self.lock.acquire()
        if len(self.pipes):
            _, pipes, _ = select([], iter(self.pipes.values()), [], 1)
            for pipe in pipes:
                os.write(pipe, n)
                os.write(pipe, frame)
        self.lock.release()

    def run(self):
        for frame in self.capture():
            self.send(frame)


class JpegRetriever(object):
    def __init__(self, streamer):
        self.streamer = streamer
        self.local = threading.local()

    def retrieve(self):
        while True:
            ns = os.read(self.local.pipe, 8)
            n = struct.unpack('l', ns)[0]
            data = os.read(self.local.pipe, n)
            yield data

    def __enter__(self):
        if hasattr(self.local, 'pipe'):
            raise RuntimeError()

        self.local.pipe = streamer.register()
        return self.retrieve()

    def __exit__(self, *args):
        self.streamer.unregister(self.local.pipe)
        del self.local.pipe
        return True


class Handler(BaseHTTPRequestHandler):
    retriever = None

    @staticmethod
    def setJpegRetriever(retriever):
        Handler.retriever = retriever

    def do_GET(self):
        if self.retriever is None:
            raise RuntimeError('no retriver')

        if self.path != '/':
            return

        self.send_response(200)
        self.send_header('Content-type', 'multipart/x-mixed-replace;boundary=abcde')
        self.end_headers()

        with self.retriever as frames:
            for frame in frames:
                self.send_frame(frame)

    def send_frame(self, frame):
        s = '--abcde\r\n'
        s += 'Content-Type: image/jpeg\r\n'
        s += 'Content-Length: %s\r\n\r\n' % len(frame)
        self.wfile.write(s.encode('ascii'))
        self.wfile.write(frame)

# é‡å†™äº†ThreadingTCPServerçš„æ–¹æ³•
def ThreadingPoolTCPServer(ThreadingTCPServer):
    def __init__(self, server_address, RequestHandlerClass, bing_and_activate=True,
                 max_thread_num = 100):
        super().__init__(server_address, RequestHandlerClass, bing_and_activate)
        self.executor = ThreadPoolExecutor(max_thread_num)

    def process_request(self, request, client_address):
        self.executor.submit(self.process_request_thread, request, client_address)

if __name__ == '__main__':
    streamer = JpegStreamer(0)
    streamer.start()

    retriever = JpegRetriever(streamer)
    Handler.setJpegRetriever(retriever)

    print('Start server...')
    httpd = ThreadingPoolTCPServer(('', 9000), Handler, max_thread_num = 3)
    httpd.serve_forever()

```
### 3. å¦‚ä½•ä½¿ç”¨å¤šè¿›ç¨‹ï¼Ÿ
**å®žé™…æ¡ˆä¾‹**  
ç”±äºŽpythonä¸­å…¨å±€è§£é‡Šå™¨(GIL)çš„å­˜åœ¨ï¼Œåœ¨ä»»æ„æ—¶åˆ»åªå…è®¸ä¸€ä¸ªçº¿ç¨‹åœ¨è§£é‡Šå…¶ä¸­è¿è¡Œï¼Œå› æ­¤pythonçš„å¤šçº¿ç¨‹ä¸é€‚åˆå¤„ç†CPUå¯†é›†åž‹çš„ä»»åŠ¡

æƒ³è¦å¤„ç†cpuå¯†é›†åž‹çš„ä»»åŠ¡å¯ä»¥ä½¿ç”¨å¤šè¿›ç¨‹æ¨¡åž‹
æ³¨ï¼šå¤šä¸ªè¿›ç¨‹ä¹‹é—´çš„å˜é‡æ˜¯ä¸åŒçš„ï¼Œå½“ä¸»è¿›ç¨‹çš„å˜é‡è½¬åˆ°å¦å¤–ä¸€ä¸ªè¿›ç¨‹ä¸­ï¼Œåœ¨æ–°çš„è¿›ç¨‹ä¸­ä¿®æ”¹äº†è¯¥å˜é‡çš„å€¼ï¼Œä½†æ˜¯åœ¨ä¸»è¿›ç¨‹ä¸­äº§çœ‹çš„æ—¶å€™è¿˜æ˜¯åŽŸæ¥çš„å˜é‡å€¼
```python
# coding:utf-8
from multiprocessing import Process, Queue, freeze_support
def f(q):
    print 'start'
    print q.get()
    print 'end'

if __name__ == '__main__':
    freeze_support()

    q = Queue()
    q.put(1)
    print q.get()

    Process(target=f, args=(q,)).start()
    q.put(2)
    # è¾“å‡ºå¦‚ä¸‹
    # 1
    # start
    # 2
    # end
```
Pipeçš„ç”¨æ³•
```python
# coding:utf-8
from multiprocessing import Pipe, Process
def f(c):
    c.send(c.recv() * 2)

if __name__ == '__main__':
    c1, c2 = Pipe()
    Process(target=f, args=(c2, )).start()
    c1.send('asdd')
    print c1.recv()
    # è¾“å‡º asddasdd
```
```python
# coding:utf-8
# CPUå¯†é›†åž‹çš„ä»»åŠ¡
from multiprocessing import Pipe, Process
from threading import Thread


def isArmstrong(n):
    a, t = [], n
    while t > 0:
        a.append(t % 10)
        t /= 10
    k = len(a)
    return sum(x ** k for x in a) == n


def findAemstrong(a, b):
    print a, b
    res = [k for k in xrange(a, b) if isArmstrong(k)]
    print '%s ~ %s: %s' % (a, b, res)


def findByThread(*argslist):
    workers = []
    for args in argslist:
        worker = Thread(target=findAemstrong, args=args)
        workers.append(worker)
        worker.start()

    for work in workers:
        worker.join()


def findByProcess(*argslist):
    workers = []
    for args in argslist:
        worker = Process(target=findAemstrong, args=args)
        workers.append(worker)
        worker.start()

    for work in workers:
        worker.join()


if __name__=='__main__':
    import time
    start = time.time()
    findByProcess((20000000, 25000000), (25000000, 30000000))
    # findByThread((20000000, 25000000), (25000000, 30000000))
    print time.time()-start
```